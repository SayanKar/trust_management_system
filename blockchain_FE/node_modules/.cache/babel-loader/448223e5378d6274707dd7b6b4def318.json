{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"stateId\"];\nimport * as React from 'react';\nimport { GridSignature } from '../utils/useGridApiEventHandler';\nimport { GridEvents } from '../../models/events';\nimport { useGridApiMethod } from '../utils';\nimport { isFunction } from '../../utils/utils';\nexport const useGridStateInitialization = (apiRef, props) => {\n  const controlStateMapRef = React.useRef({});\n  const [, rawForceUpdate] = React.useState();\n  const updateControlState = React.useCallback(controlStateItem => {\n    const {\n      stateId\n    } = controlStateItem,\n          others = _objectWithoutPropertiesLoose(controlStateItem, _excluded);\n\n    controlStateMapRef.current[stateId] = _extends({}, others, {\n      stateId\n    });\n  }, []);\n  const setState = React.useCallback(state => {\n    let newState;\n\n    if (isFunction(state)) {\n      newState = state(apiRef.current.state);\n    } else {\n      newState = state;\n    }\n\n    if (apiRef.current.state === newState) {\n      return false;\n    }\n\n    let ignoreSetState = false; // Apply the control state constraints\n\n    const updatedControlStateIds = [];\n    Object.keys(controlStateMapRef.current).forEach(stateId => {\n      const controlState = controlStateMapRef.current[stateId];\n      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);\n      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (newSubState === oldSubState) {\n        return;\n      }\n\n      updatedControlStateIds.push({\n        stateId: controlState.stateId,\n        hasPropChanged: newSubState !== controlState.propModel\n      }); // The state is controlled, the prop should always win\n\n      if (controlState.propModel !== undefined && newSubState !== controlState.propModel) {\n        ignoreSetState = true;\n      }\n    });\n\n    if (updatedControlStateIds.length > 1) {\n      // Each hook modify its own state, and it should not leak\n      // Events are here to forward to other hooks and apply changes.\n      // You are trying to update several states in a no isolated way.\n      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map(el => el.stateId).join(', ')} in the same transaction.`);\n    }\n\n    if (!ignoreSetState) {\n      // We always assign it as we mutate rows for perf reason.\n      apiRef.current.state = newState;\n\n      if (apiRef.current.publishEvent) {\n        apiRef.current.publishEvent(GridEvents.stateChange, newState);\n      }\n    }\n\n    if (updatedControlStateIds.length === 1) {\n      const {\n        stateId,\n        hasPropChanged\n      } = updatedControlStateIds[0];\n      const controlState = controlStateMapRef.current[stateId];\n      const model = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (controlState.propOnChange && hasPropChanged) {\n        const details = props.signature === GridSignature.DataGridPro ? {\n          api: apiRef.current\n        } : {};\n        controlState.propOnChange(model, details);\n      }\n\n      if (!ignoreSetState) {\n        apiRef.current.publishEvent(controlState.changeEvent, model);\n      }\n    }\n\n    return !ignoreSetState;\n  }, [apiRef, props.signature]);\n  const forceUpdate = React.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);\n  const stateApi = {\n    setState,\n    forceUpdate,\n    unstable_updateControlState: updateControlState\n  };\n  useGridApiMethod(apiRef, stateApi, 'GridStateApi');\n};","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","GridSignature","GridEvents","useGridApiMethod","isFunction","useGridStateInitialization","apiRef","props","controlStateMapRef","useRef","rawForceUpdate","useState","updateControlState","useCallback","controlStateItem","stateId","others","current","setState","state","newState","ignoreSetState","updatedControlStateIds","Object","keys","forEach","controlState","oldSubState","stateSelector","instanceId","newSubState","push","hasPropChanged","propModel","undefined","length","Error","map","el","join","publishEvent","stateChange","model","propOnChange","details","signature","DataGridPro","api","changeEvent","forceUpdate","stateApi","unstable_updateControlState"],"sources":["/Users/yashkothari/project/blockchain_project/node_modules/@mui/x-data-grid/hooks/core/useGridStateInitialization.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"stateId\"];\nimport * as React from 'react';\nimport { GridSignature } from '../utils/useGridApiEventHandler';\nimport { GridEvents } from '../../models/events';\nimport { useGridApiMethod } from '../utils';\nimport { isFunction } from '../../utils/utils';\nexport const useGridStateInitialization = (apiRef, props) => {\n  const controlStateMapRef = React.useRef({});\n  const [, rawForceUpdate] = React.useState();\n  const updateControlState = React.useCallback(controlStateItem => {\n    const {\n      stateId\n    } = controlStateItem,\n          others = _objectWithoutPropertiesLoose(controlStateItem, _excluded);\n\n    controlStateMapRef.current[stateId] = _extends({}, others, {\n      stateId\n    });\n  }, []);\n  const setState = React.useCallback(state => {\n    let newState;\n\n    if (isFunction(state)) {\n      newState = state(apiRef.current.state);\n    } else {\n      newState = state;\n    }\n\n    if (apiRef.current.state === newState) {\n      return false;\n    }\n\n    let ignoreSetState = false; // Apply the control state constraints\n\n    const updatedControlStateIds = [];\n    Object.keys(controlStateMapRef.current).forEach(stateId => {\n      const controlState = controlStateMapRef.current[stateId];\n      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);\n      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (newSubState === oldSubState) {\n        return;\n      }\n\n      updatedControlStateIds.push({\n        stateId: controlState.stateId,\n        hasPropChanged: newSubState !== controlState.propModel\n      }); // The state is controlled, the prop should always win\n\n      if (controlState.propModel !== undefined && newSubState !== controlState.propModel) {\n        ignoreSetState = true;\n      }\n    });\n\n    if (updatedControlStateIds.length > 1) {\n      // Each hook modify its own state, and it should not leak\n      // Events are here to forward to other hooks and apply changes.\n      // You are trying to update several states in a no isolated way.\n      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map(el => el.stateId).join(', ')} in the same transaction.`);\n    }\n\n    if (!ignoreSetState) {\n      // We always assign it as we mutate rows for perf reason.\n      apiRef.current.state = newState;\n\n      if (apiRef.current.publishEvent) {\n        apiRef.current.publishEvent(GridEvents.stateChange, newState);\n      }\n    }\n\n    if (updatedControlStateIds.length === 1) {\n      const {\n        stateId,\n        hasPropChanged\n      } = updatedControlStateIds[0];\n      const controlState = controlStateMapRef.current[stateId];\n      const model = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (controlState.propOnChange && hasPropChanged) {\n        const details = props.signature === GridSignature.DataGridPro ? {\n          api: apiRef.current\n        } : {};\n        controlState.propOnChange(model, details);\n      }\n\n      if (!ignoreSetState) {\n        apiRef.current.publishEvent(controlState.changeEvent, model);\n      }\n    }\n\n    return !ignoreSetState;\n  }, [apiRef, props.signature]);\n  const forceUpdate = React.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);\n  const stateApi = {\n    setState,\n    forceUpdate,\n    unstable_updateControlState: updateControlState\n  };\n  useGridApiMethod(apiRef, stateApi, 'GridStateApi');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}