{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { checkGridRowIdIsValid } from './gridRowsUtils';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nconst convertGridRowsPropToState = _ref2 => {\n  let {\n    prevState,\n    rows,\n    getRowId\n  } = _ref2;\n  let value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      ids: []\n    };\n\n    for (let i = 0; i < rows.length; i += 1) {\n      const row = rows[i];\n      const id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nconst getRowsStateFromCache = (rowsCache, previousTree, apiRef, rowCountProp, loadingProp) => {\n  const {\n    value\n  } = rowsCache.state;\n  const rowCount = rowCountProp != null ? rowCountProp : 0;\n  const groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', _extends({}, value, {\n    previousTree\n  }));\n  const dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(node => node.parent == null).length;\n  return _extends({}, groupingResponse, {\n    loading: loadingProp,\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  const rowsCache = {\n    state: convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: {\n        value: {\n          idRowsLookup: {},\n          ids: []\n        },\n        rowsBeforePartialUpdates: []\n      }\n    }),\n    timeout: null,\n    lastUpdateMs: Date.now()\n  };\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(rowsCache, null, apiRef, props.rowCount, props.loading),\n    rowsCache // TODO remove from state\n\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const rowsCache = React.useRef(apiRef.current.state.rowsCache); // To avoid listing rowsCache as useEffect dep\n\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, _ref3, index) => {\n    let {\n      id\n    } = _ref3;\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newState, throttle) => {\n    const run = () => {\n      rowsCache.current.timeout = null;\n      rowsCache.current.lastUpdateMs = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache(rowsCache.current, gridRowTreeSelector(apiRef), apiRef, props.rowCount, props.loading)\n      }));\n      apiRef.current.publishEvent(GridEvents.rowsSet);\n      apiRef.current.forceUpdate();\n    };\n\n    if (rowsCache.current.timeout) {\n      clearTimeout(rowsCache.current.timeout);\n    }\n\n    rowsCache.current.state = newState;\n    rowsCache.current.timeout = null;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - rowsCache.current.lastUpdateMs);\n\n    if (throttleRemainingTimeMs > 0) {\n      rowsCache.current.timeout = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(convertGridRowsPropToState({\n      rows,\n      prevState: rowsCache.current.state,\n      getRowId: props.getRowId\n    }), true);\n  }, [logger, props.getRowId, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const newStateValue = {\n      idRowsLookup: _extends({}, rowsCache.current.state.value.idRowsLookup),\n      ids: [...rowsCache.current.state.value.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    const state = _extends({}, rowsCache.current.state, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [apiRef, props.getRowId, throttledRowsChange, props.signature]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.rowExpansionChange, newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.applySorting();\n  }, [apiRef, logger]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let rows;\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertGridRowsPropToState({\n      rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [logger, throttledRowsChange, props.getRowId, props.rows]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, GridEvents.activeStrategyProcessorChange, handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, GridEvents.strategyAvailabilityChange, handleStrategyActivityChange);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (rowsCache.current.timeout !== null) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        clearTimeout(rowsCache.current.timeout);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `GridEvents.rowGroupsPreProcessingChange` listener)\n\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange]);\n};","map":{"version":3,"names":["_extends","React","GridEvents","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","gridRowGroupingNameSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","checkGridRowIdIsValid","getGridRowId","rowModel","getRowId","detailErrorMessage","id","convertGridRowsPropToState","prevState","rows","value","idRowsLookup","ids","i","length","row","push","rowsBeforePartialUpdates","getRowsStateFromCache","rowsCache","previousTree","apiRef","rowCountProp","loadingProp","state","rowCount","groupingResponse","current","unstable_applyStrategyProcessor","dataTopLevelRowCount","treeDepth","Object","values","tree","filter","node","parent","loading","totalRowCount","Math","max","totalTopLevelRowCount","rowsStateInitializer","props","timeout","lastUpdateMs","Date","now","useGridRows","process","env","NODE_ENV","freeze","logger","useRef","currentPage","getRow","useCallback","_ref","lookup","useMemo","reduce","acc","index","throttledRowsChange","newState","throttle","run","setState","publishEvent","rowsSet","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","updateRows","updates","signature","DataGrid","Error","join","uniqUpdates","Map","forEach","update","has","set","get","deletedRowIds","newStateValue","partialRow","_action","oldRow","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","rowExpansionChange","_gridRowTreeSelector$","setRowIndex","rowId","targetIndex","oldIndex","findIndex","updatedRows","splice","applySorting","rowApi","groupRows","info","undefined","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","unstable_getActiveStrategy","activeStrategyProcessorChange","strategyAvailabilityChange","useEffect","isFirstRender"],"sources":["/Users/yashkothari/project/blockchain_project/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { checkGridRowIdIsValid } from './gridRowsUtils';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nconst convertGridRowsPropToState = ({\n  prevState,\n  rows,\n  getRowId\n}) => {\n  let value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      ids: []\n    };\n\n    for (let i = 0; i < rows.length; i += 1) {\n      const row = rows[i];\n      const id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nconst getRowsStateFromCache = (rowsCache, previousTree, apiRef, rowCountProp, loadingProp) => {\n  const {\n    value\n  } = rowsCache.state;\n  const rowCount = rowCountProp != null ? rowCountProp : 0;\n  const groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', _extends({}, value, {\n    previousTree\n  }));\n  const dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(node => node.parent == null).length;\n  return _extends({}, groupingResponse, {\n    loading: loadingProp,\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  const rowsCache = {\n    state: convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: {\n        value: {\n          idRowsLookup: {},\n          ids: []\n        },\n        rowsBeforePartialUpdates: []\n      }\n    }),\n    timeout: null,\n    lastUpdateMs: Date.now()\n  };\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(rowsCache, null, apiRef, props.rowCount, props.loading),\n    rowsCache // TODO remove from state\n\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const rowsCache = React.useRef(apiRef.current.state.rowsCache); // To avoid listing rowsCache as useEffect dep\n\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newState, throttle) => {\n    const run = () => {\n      rowsCache.current.timeout = null;\n      rowsCache.current.lastUpdateMs = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache(rowsCache.current, gridRowTreeSelector(apiRef), apiRef, props.rowCount, props.loading)\n      }));\n      apiRef.current.publishEvent(GridEvents.rowsSet);\n      apiRef.current.forceUpdate();\n    };\n\n    if (rowsCache.current.timeout) {\n      clearTimeout(rowsCache.current.timeout);\n    }\n\n    rowsCache.current.state = newState;\n    rowsCache.current.timeout = null;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - rowsCache.current.lastUpdateMs);\n\n    if (throttleRemainingTimeMs > 0) {\n      rowsCache.current.timeout = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(convertGridRowsPropToState({\n      rows,\n      prevState: rowsCache.current.state,\n      getRowId: props.getRowId\n    }), true);\n  }, [logger, props.getRowId, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const newStateValue = {\n      idRowsLookup: _extends({}, rowsCache.current.state.value.idRowsLookup),\n      ids: [...rowsCache.current.state.value.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    const state = _extends({}, rowsCache.current.state, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [apiRef, props.getRowId, throttledRowsChange, props.signature]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.rowExpansionChange, newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.applySorting();\n  }, [apiRef, logger]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let rows;\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertGridRowsPropToState({\n      rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [logger, throttledRowsChange, props.getRowId, props.rows]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, GridEvents.activeStrategyProcessorChange, handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, GridEvents.strategyAvailabilityChange, handleStrategyActivityChange);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (rowsCache.current.timeout !== null) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        clearTimeout(rowsCache.current.timeout);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `GridEvents.rowGroupsPreProcessingChange` listener)\n\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange]);\n};"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,aAAT,QAA8B,2BAA9B;AACA,SAASC,oBAAT,EAA+BC,sBAA/B,EAAuDC,mBAAvD,EAA4EC,kBAA5E,EAAgGC,2BAAhG,QAAmI,oBAAnI;AACA,SAASC,aAAT,EAAwBC,sBAAxB,QAAsD,oCAAtD;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AACA,SAASC,qBAAT,QAAsC,iBAAtC;;AAEA,SAASC,YAAT,CAAsBC,QAAtB,EAAgCC,QAAhC,EAA0CC,kBAA1C,EAA8D;EAC5D,MAAMC,EAAE,GAAGF,QAAQ,GAAGA,QAAQ,CAACD,QAAD,CAAX,GAAwBA,QAAQ,CAACG,EAApD;EACAL,qBAAqB,CAACK,EAAD,EAAKH,QAAL,EAAeE,kBAAf,CAArB;EACA,OAAOC,EAAP;AACD;;AAED,MAAMC,0BAA0B,GAAG,SAI7B;EAAA,IAJ8B;IAClCC,SADkC;IAElCC,IAFkC;IAGlCL;EAHkC,CAI9B;EACJ,IAAIM,KAAJ;;EAEA,IAAID,IAAJ,EAAU;IACRC,KAAK,GAAG;MACNC,YAAY,EAAE,EADR;MAENC,GAAG,EAAE;IAFC,CAAR;;IAKA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACK,MAAzB,EAAiCD,CAAC,IAAI,CAAtC,EAAyC;MACvC,MAAME,GAAG,GAAGN,IAAI,CAACI,CAAD,CAAhB;MACA,MAAMP,EAAE,GAAGJ,YAAY,CAACa,GAAD,EAAMX,QAAN,CAAvB;MACAM,KAAK,CAACC,YAAN,CAAmBL,EAAnB,IAAyBS,GAAzB;MACAL,KAAK,CAACE,GAAN,CAAUI,IAAV,CAAeV,EAAf;IACD;EACF,CAZD,MAYO;IACLI,KAAK,GAAGF,SAAS,CAACE,KAAlB;EACD;;EAED,OAAO;IACLA,KADK;IAELO,wBAAwB,EAAER,IAAI,IAAI,IAAR,GAAeA,IAAf,GAAsBD,SAAS,CAACS;EAFrD,CAAP;AAID,CA3BD;;AA6BA,MAAMC,qBAAqB,GAAG,CAACC,SAAD,EAAYC,YAAZ,EAA0BC,MAA1B,EAAkCC,YAAlC,EAAgDC,WAAhD,KAAgE;EAC5F,MAAM;IACJb;EADI,IAEFS,SAAS,CAACK,KAFd;EAGA,MAAMC,QAAQ,GAAGH,YAAY,IAAI,IAAhB,GAAuBA,YAAvB,GAAsC,CAAvD;EACA,MAAMI,gBAAgB,GAAGL,MAAM,CAACM,OAAP,CAAeC,+BAAf,CAA+C,iBAA/C,EAAkExC,QAAQ,CAAC,EAAD,EAAKsB,KAAL,EAAY;IAC7GU;EAD6G,CAAZ,CAA1E,CAAzB;EAGA,MAAMS,oBAAoB,GAAGH,gBAAgB,CAACI,SAAjB,KAA+B,CAA/B,GAAmCJ,gBAAgB,CAACd,GAAjB,CAAqBE,MAAxD,GAAiEiB,MAAM,CAACC,MAAP,CAAcN,gBAAgB,CAACO,IAA/B,EAAqCC,MAArC,CAA4CC,IAAI,IAAIA,IAAI,CAACC,MAAL,IAAe,IAAnE,EAAyEtB,MAAvK;EACA,OAAO1B,QAAQ,CAAC,EAAD,EAAKsC,gBAAL,EAAuB;IACpCW,OAAO,EAAEd,WAD2B;IAEpCe,aAAa,EAAEC,IAAI,CAACC,GAAL,CAASf,QAAT,EAAmBC,gBAAgB,CAACd,GAAjB,CAAqBE,MAAxC,CAFqB;IAGpC2B,qBAAqB,EAAEF,IAAI,CAACC,GAAL,CAASf,QAAT,EAAmBI,oBAAnB;EAHa,CAAvB,CAAf;AAKD,CAdD;;AAgBA,OAAO,MAAMa,oBAAoB,GAAG,CAAClB,KAAD,EAAQmB,KAAR,EAAetB,MAAf,KAA0B;EAC5D,MAAMF,SAAS,GAAG;IAChBK,KAAK,EAAEjB,0BAA0B,CAAC;MAChCE,IAAI,EAAEkC,KAAK,CAAClC,IADoB;MAEhCL,QAAQ,EAAEuC,KAAK,CAACvC,QAFgB;MAGhCI,SAAS,EAAE;QACTE,KAAK,EAAE;UACLC,YAAY,EAAE,EADT;UAELC,GAAG,EAAE;QAFA,CADE;QAKTK,wBAAwB,EAAE;MALjB;IAHqB,CAAD,CADjB;IAYhB2B,OAAO,EAAE,IAZO;IAahBC,YAAY,EAAEC,IAAI,CAACC,GAAL;EAbE,CAAlB;EAeA,OAAO3D,QAAQ,CAAC,EAAD,EAAKoC,KAAL,EAAY;IACzBf,IAAI,EAAES,qBAAqB,CAACC,SAAD,EAAY,IAAZ,EAAkBE,MAAlB,EAA0BsB,KAAK,CAAClB,QAAhC,EAA0CkB,KAAK,CAACN,OAAhD,CADF;IAEzBlB,SAFyB,CAEf;;EAFe,CAAZ,CAAf;AAKD,CArBM;AAsBP,OAAO,MAAM6B,WAAW,GAAG,CAAC3B,MAAD,EAASsB,KAAT,KAAmB;EAC5C,IAAIM,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACApB,MAAM,CAACqB,MAAP,CAAcT,KAAK,CAAClC,IAApB;EACD;;EAED,MAAM4C,MAAM,GAAG7D,aAAa,CAAC6B,MAAD,EAAS,aAAT,CAA5B;EACA,MAAMF,SAAS,GAAG9B,KAAK,CAACiE,MAAN,CAAajC,MAAM,CAACM,OAAP,CAAeH,KAAf,CAAqBL,SAAlC,CAAlB,CAP4C,CAOoB;;EAEhE,MAAMoC,WAAW,GAAGvD,kBAAkB,CAACqB,MAAD,EAASsB,KAAT,CAAtC;EACA,MAAMa,MAAM,GAAGnE,KAAK,CAACoE,WAAN,CAAkBnD,EAAE,IAAI;IACrC,IAAIoD,IAAJ;;IAEA,OAAO,CAACA,IAAI,GAAGhE,sBAAsB,CAAC2B,MAAD,CAAtB,CAA+Bf,EAA/B,CAAR,KAA+C,IAA/C,GAAsDoD,IAAtD,GAA6D,IAApE;EACD,CAJc,EAIZ,CAACrC,MAAD,CAJY,CAAf;EAKA,MAAMsC,MAAM,GAAGtE,KAAK,CAACuE,OAAN,CAAc,MAAML,WAAW,CAAC9C,IAAZ,CAAiBoD,MAAjB,CAAwB,CAACC,GAAD,SAExDC,KAFwD,KAE9C;IAAA,IAFoD;MAC/DzD;IAD+D,CAEpD;IACXwD,GAAG,CAACxD,EAAD,CAAH,GAAUyD,KAAV;IACA,OAAOD,GAAP;EACD,CALkC,EAKhC,EALgC,CAApB,EAKP,CAACP,WAAW,CAAC9C,IAAb,CALO,CAAf;EAMA,MAAMuD,mBAAmB,GAAG3E,KAAK,CAACoE,WAAN,CAAkB,CAACQ,QAAD,EAAWC,QAAX,KAAwB;IACpE,MAAMC,GAAG,GAAG,MAAM;MAChBhD,SAAS,CAACQ,OAAV,CAAkBiB,OAAlB,GAA4B,IAA5B;MACAzB,SAAS,CAACQ,OAAV,CAAkBkB,YAAlB,GAAiCC,IAAI,CAACC,GAAL,EAAjC;MACA1B,MAAM,CAACM,OAAP,CAAeyC,QAAf,CAAwB5C,KAAK,IAAIpC,QAAQ,CAAC,EAAD,EAAKoC,KAAL,EAAY;QACnDf,IAAI,EAAES,qBAAqB,CAACC,SAAS,CAACQ,OAAX,EAAoBhC,mBAAmB,CAAC0B,MAAD,CAAvC,EAAiDA,MAAjD,EAAyDsB,KAAK,CAAClB,QAA/D,EAAyEkB,KAAK,CAACN,OAA/E;MADwB,CAAZ,CAAzC;MAGAhB,MAAM,CAACM,OAAP,CAAe0C,YAAf,CAA4B/E,UAAU,CAACgF,OAAvC;MACAjD,MAAM,CAACM,OAAP,CAAe4C,WAAf;IACD,CARD;;IAUA,IAAIpD,SAAS,CAACQ,OAAV,CAAkBiB,OAAtB,EAA+B;MAC7B4B,YAAY,CAACrD,SAAS,CAACQ,OAAV,CAAkBiB,OAAnB,CAAZ;IACD;;IAEDzB,SAAS,CAACQ,OAAV,CAAkBH,KAAlB,GAA0ByC,QAA1B;IACA9C,SAAS,CAACQ,OAAV,CAAkBiB,OAAlB,GAA4B,IAA5B;;IAEA,IAAI,CAACsB,QAAL,EAAe;MACbC,GAAG;MACH;IACD;;IAED,MAAMM,uBAAuB,GAAG9B,KAAK,CAAC+B,cAAN,IAAwB5B,IAAI,CAACC,GAAL,KAAa5B,SAAS,CAACQ,OAAV,CAAkBkB,YAAvD,CAAhC;;IAEA,IAAI4B,uBAAuB,GAAG,CAA9B,EAAiC;MAC/BtD,SAAS,CAACQ,OAAV,CAAkBiB,OAAlB,GAA4B+B,UAAU,CAACR,GAAD,EAAMM,uBAAN,CAAtC;MACA;IACD;;IAEDN,GAAG;EACJ,CA/B2B,EA+BzB,CAACxB,KAAK,CAAC+B,cAAP,EAAuB/B,KAAK,CAAClB,QAA7B,EAAuCkB,KAAK,CAACN,OAA7C,EAAsDhB,MAAtD,CA/ByB,CAA5B;EAgCA;AACF;AACA;;EAEE,MAAMuD,OAAO,GAAGvF,KAAK,CAACoE,WAAN,CAAkBhD,IAAI,IAAI;IACxC4C,MAAM,CAACwB,KAAP,CAAc,iCAAgCpE,IAAI,CAACK,MAAO,EAA1D;IACAkD,mBAAmB,CAACzD,0BAA0B,CAAC;MAC7CE,IAD6C;MAE7CD,SAAS,EAAEW,SAAS,CAACQ,OAAV,CAAkBH,KAFgB;MAG7CpB,QAAQ,EAAEuC,KAAK,CAACvC;IAH6B,CAAD,CAA3B,EAIf,IAJe,CAAnB;EAKD,CAPe,EAOb,CAACiD,MAAD,EAASV,KAAK,CAACvC,QAAf,EAAyB4D,mBAAzB,CAPa,CAAhB;EAQA,MAAMc,UAAU,GAAGzF,KAAK,CAACoE,WAAN,CAAkBsB,OAAO,IAAI;IAC9C,IAAIpC,KAAK,CAACqC,SAAN,KAAoBlF,aAAa,CAACmF,QAAlC,IAA8CF,OAAO,CAACjE,MAAR,GAAiB,CAAnE,EAAsE;MACpE;MACA,MAAM,IAAIoE,KAAJ,CAAU,CAAC,4FAAD,EAA+F,0EAA/F,EAA2KC,IAA3K,CAAgL,IAAhL,CAAV,CAAN;IACD,CAJ6C,CAI5C;;;IAGF,MAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;IACAN,OAAO,CAACO,OAAR,CAAgBC,MAAM,IAAI;MACxB,MAAMjF,EAAE,GAAGJ,YAAY,CAACqF,MAAD,EAAS5C,KAAK,CAACvC,QAAf,EAAyB,0DAAzB,CAAvB;;MAEA,IAAIgF,WAAW,CAACI,GAAZ,CAAgBlF,EAAhB,CAAJ,EAAyB;QACvB8E,WAAW,CAACK,GAAZ,CAAgBnF,EAAhB,EAAoBlB,QAAQ,CAAC,EAAD,EAAKgG,WAAW,CAACM,GAAZ,CAAgBpF,EAAhB,CAAL,EAA0BiF,MAA1B,CAA5B;MACD,CAFD,MAEO;QACLH,WAAW,CAACK,GAAZ,CAAgBnF,EAAhB,EAAoBiF,MAApB;MACD;IACF,CARD;IASA,MAAMI,aAAa,GAAG,EAAtB;IACA,MAAMC,aAAa,GAAG;MACpBjF,YAAY,EAAEvB,QAAQ,CAAC,EAAD,EAAK+B,SAAS,CAACQ,OAAV,CAAkBH,KAAlB,CAAwBd,KAAxB,CAA8BC,YAAnC,CADF;MAEpBC,GAAG,EAAE,CAAC,GAAGO,SAAS,CAACQ,OAAV,CAAkBH,KAAlB,CAAwBd,KAAxB,CAA8BE,GAAlC;IAFe,CAAtB;IAIAwE,WAAW,CAACE,OAAZ,CAAoB,CAACO,UAAD,EAAavF,EAAb,KAAoB;MACtC;MACA,IAAIuF,UAAU,CAACC,OAAX,KAAuB,QAA3B,EAAqC;QACnC,OAAOF,aAAa,CAACjF,YAAd,CAA2BL,EAA3B,CAAP;QACAqF,aAAa,CAAC3E,IAAd,CAAmBV,EAAnB;QACA;MACD;;MAED,MAAMyF,MAAM,GAAG1E,MAAM,CAACM,OAAP,CAAe6B,MAAf,CAAsBlD,EAAtB,CAAf;;MAEA,IAAI,CAACyF,MAAL,EAAa;QACXH,aAAa,CAACjF,YAAd,CAA2BL,EAA3B,IAAiCuF,UAAjC;QACAD,aAAa,CAAChF,GAAd,CAAkBI,IAAlB,CAAuBV,EAAvB;QACA;MACD;;MAEDsF,aAAa,CAACjF,YAAd,CAA2BL,EAA3B,IAAiClB,QAAQ,CAAC,EAAD,EAAKiC,MAAM,CAACM,OAAP,CAAe6B,MAAf,CAAsBlD,EAAtB,CAAL,EAAgCuF,UAAhC,CAAzC;IACD,CAjBD;;IAmBA,IAAIF,aAAa,CAAC7E,MAAd,GAAuB,CAA3B,EAA8B;MAC5B8E,aAAa,CAAChF,GAAd,GAAoBgF,aAAa,CAAChF,GAAd,CAAkBsB,MAAlB,CAAyB5B,EAAE,IAAI,CAACqF,aAAa,CAACK,QAAd,CAAuB1F,EAAvB,CAAhC,CAApB;IACD;;IAED,MAAMkB,KAAK,GAAGpC,QAAQ,CAAC,EAAD,EAAK+B,SAAS,CAACQ,OAAV,CAAkBH,KAAvB,EAA8B;MAClDd,KAAK,EAAEkF;IAD2C,CAA9B,CAAtB;;IAIA5B,mBAAmB,CAACxC,KAAD,EAAQ,IAAR,CAAnB;EACD,CAlDkB,EAkDhB,CAACH,MAAD,EAASsB,KAAK,CAACvC,QAAf,EAAyB4D,mBAAzB,EAA8CrB,KAAK,CAACqC,SAApD,CAlDgB,CAAnB;EAmDA,MAAMiB,YAAY,GAAG5G,KAAK,CAACoE,WAAN,CAAkB,MAAM;IAC3C,MAAMyC,OAAO,GAAGtG,kBAAkB,CAACyB,MAAD,CAAlC;IACA,MAAMV,YAAY,GAAGjB,sBAAsB,CAAC2B,MAAD,CAA3C;IACA,OAAO,IAAIgE,GAAJ,CAAQa,OAAO,CAACC,GAAR,CAAY7F,EAAE,IAAI,CAACA,EAAD,EAAKK,YAAY,CAACL,EAAD,CAAjB,CAAlB,CAAR,CAAP;EACD,CAJoB,EAIlB,CAACe,MAAD,CAJkB,CAArB;EAKA,MAAM+E,YAAY,GAAG/G,KAAK,CAACoE,WAAN,CAAkB,MAAMhE,oBAAoB,CAAC4B,MAAD,CAA5C,EAAsD,CAACA,MAAD,CAAtD,CAArB;EACA,MAAMgF,YAAY,GAAGhH,KAAK,CAACoE,WAAN,CAAkB,MAAM7D,kBAAkB,CAACyB,MAAD,CAA1C,EAAoD,CAACA,MAAD,CAApD,CAArB;EACA,MAAMiF,gCAAgC,GAAGjH,KAAK,CAACoE,WAAN,CAAkBnD,EAAE,IAAIqD,MAAM,CAACrD,EAAD,CAA9B,EAAoC,CAACqD,MAAD,CAApC,CAAzC;EACA,MAAM4C,uBAAuB,GAAGlH,KAAK,CAACoE,WAAN,CAAkB,CAACnD,EAAD,EAAKkG,UAAL,KAAoB;IACpE,MAAMC,WAAW,GAAGpF,MAAM,CAACM,OAAP,CAAe+E,UAAf,CAA0BpG,EAA1B,CAApB;;IAEA,IAAI,CAACmG,WAAL,EAAkB;MAChB,MAAM,IAAIvB,KAAJ,CAAW,wBAAuB5E,EAAG,QAArC,CAAN;IACD;;IAED,MAAMqG,OAAO,GAAGvH,QAAQ,CAAC,EAAD,EAAKqH,WAAL,EAAkB;MACxCG,gBAAgB,EAAEJ;IADsB,CAAlB,CAAxB;;IAIAnF,MAAM,CAACM,OAAP,CAAeyC,QAAf,CAAwB5C,KAAK,IAAI;MAC/B,OAAOpC,QAAQ,CAAC,EAAD,EAAKoC,KAAL,EAAY;QACzBf,IAAI,EAAErB,QAAQ,CAAC,EAAD,EAAKoC,KAAK,CAACf,IAAX,EAAiB;UAC7BwB,IAAI,EAAE7C,QAAQ,CAAC,EAAD,EAAKoC,KAAK,CAACf,IAAN,CAAWwB,IAAhB,EAAsB;YAClC,CAAC3B,EAAD,GAAMqG;UAD4B,CAAtB;QADe,CAAjB;MADW,CAAZ,CAAf;IAOD,CARD;IASAtF,MAAM,CAACM,OAAP,CAAe4C,WAAf;IACAlD,MAAM,CAACM,OAAP,CAAe0C,YAAf,CAA4B/E,UAAU,CAACuH,kBAAvC,EAA2DF,OAA3D;EACD,CAtB+B,EAsB7B,CAACtF,MAAD,CAtB6B,CAAhC;EAuBA,MAAMqF,UAAU,GAAGrH,KAAK,CAACoE,WAAN,CAAkBnD,EAAE,IAAI;IACzC,IAAIwG,qBAAJ;;IAEA,OAAO,CAACA,qBAAqB,GAAGnH,mBAAmB,CAAC0B,MAAD,CAAnB,CAA4Bf,EAA5B,CAAzB,KAA6D,IAA7D,GAAoEwG,qBAApE,GAA4F,IAAnG;EACD,CAJkB,EAIhB,CAACzF,MAAD,CAJgB,CAAnB;EAKA,MAAM0F,WAAW,GAAG1H,KAAK,CAACoE,WAAN,CAAkB,CAACuD,KAAD,EAAQC,WAAR,KAAwB;IAC5D,MAAMf,OAAO,GAAGtG,kBAAkB,CAACyB,MAAD,CAAlC;IACA,MAAM6F,QAAQ,GAAGhB,OAAO,CAACiB,SAAR,CAAkBpG,GAAG,IAAIA,GAAG,KAAKiG,KAAjC,CAAjB;;IAEA,IAAIE,QAAQ,KAAKD,WAAjB,EAA8B;MAC5B;IACD;;IAED5D,MAAM,CAACwB,KAAP,CAAc,cAAamC,KAAM,aAAYC,WAAY,EAAzD;IACA,MAAMG,WAAW,GAAG,CAAC,GAAGlB,OAAJ,CAApB;IACAkB,WAAW,CAACC,MAAZ,CAAmBJ,WAAnB,EAAgC,CAAhC,EAAmCG,WAAW,CAACC,MAAZ,CAAmBH,QAAnB,EAA6B,CAA7B,EAAgC,CAAhC,CAAnC;IACA7F,MAAM,CAACM,OAAP,CAAeyC,QAAf,CAAwB5C,KAAK,IAAIpC,QAAQ,CAAC,EAAD,EAAKoC,KAAL,EAAY;MACnDf,IAAI,EAAErB,QAAQ,CAAC,EAAD,EAAKoC,KAAK,CAACf,IAAX,EAAiB;QAC7BG,GAAG,EAAEwG;MADwB,CAAjB;IADqC,CAAZ,CAAzC;IAKA/F,MAAM,CAACM,OAAP,CAAe2F,YAAf;EACD,CAjBmB,EAiBjB,CAACjG,MAAD,EAASgC,MAAT,CAjBiB,CAApB;EAkBA,MAAMkE,MAAM,GAAG;IACb/D,MADa;IAEbyC,YAFa;IAGbG,YAHa;IAIbC,YAJa;IAKbzB,OALa;IAMbmC,WANa;IAObjC,UAPa;IAQbyB,uBARa;IASbG,UATa;IAUbJ;EAVa,CAAf;EAYA;AACF;AACA;;EAEE,MAAMkB,SAAS,GAAGnI,KAAK,CAACoE,WAAN,CAAkB,MAAM;IACxCJ,MAAM,CAACoE,IAAP,CAAa,qEAAb;IACA,IAAIhH,IAAJ;;IAEA,IAAIU,SAAS,CAACQ,OAAV,CAAkBH,KAAlB,CAAwBP,wBAAxB,KAAqD0B,KAAK,CAAClC,IAA/D,EAAqE;MACnE;MACA;MACAA,IAAI,GAAGiH,SAAP;IACD,CAJD,MAIO;MACL;MACA;MACA;MACAjH,IAAI,GAAGkC,KAAK,CAAClC,IAAb;IACD;;IAEDuD,mBAAmB,CAACzD,0BAA0B,CAAC;MAC7CE,IAD6C;MAE7CL,QAAQ,EAAEuC,KAAK,CAACvC,QAF6B;MAG7CI,SAAS,EAAEW,SAAS,CAACQ,OAAV,CAAkBH;IAHgB,CAAD,CAA3B,EAIf,KAJe,CAAnB;EAKD,CApBiB,EAoBf,CAAC6B,MAAD,EAASW,mBAAT,EAA8BrB,KAAK,CAACvC,QAApC,EAA8CuC,KAAK,CAAClC,IAApD,CApBe,CAAlB;EAqBA,MAAMkH,6BAA6B,GAAGtI,KAAK,CAACoE,WAAN,CAAkBmE,UAAU,IAAI;IACpE,IAAIA,UAAU,KAAK,iBAAnB,EAAsC;MACpCJ,SAAS;IACV;EACF,CAJqC,EAInC,CAACA,SAAD,CAJmC,CAAtC;EAKA,MAAMK,4BAA4B,GAAGxI,KAAK,CAACoE,WAAN,CAAkB,MAAM;IAC3D;IACA;IACA,IAAIpC,MAAM,CAACM,OAAP,CAAemG,0BAAf,CAA0C,SAA1C,MAAyDjI,2BAA2B,CAACwB,MAAD,CAAxF,EAAkG;MAChGmG,SAAS;IACV;EACF,CANoC,EAMlC,CAACnG,MAAD,EAASmG,SAAT,CANkC,CAArC;EAOAzH,sBAAsB,CAACsB,MAAD,EAAS/B,UAAU,CAACyI,6BAApB,EAAmDJ,6BAAnD,CAAtB;EACA5H,sBAAsB,CAACsB,MAAD,EAAS/B,UAAU,CAAC0I,0BAApB,EAAgDH,4BAAhD,CAAtB;EACAtI,gBAAgB,CAAC8B,MAAD,EAASkG,MAAT,EAAiB,YAAjB,CAAhB;EACA;AACF;AACA;;EAEElI,KAAK,CAAC4I,SAAN,CAAgB,MAAM;IACpB,OAAO,MAAM;MACX,IAAI9G,SAAS,CAACQ,OAAV,CAAkBiB,OAAlB,KAA8B,IAAlC,EAAwC;QACtC;QACA4B,YAAY,CAACrD,SAAS,CAACQ,OAAV,CAAkBiB,OAAnB,CAAZ;MACD;IACF,CALD;EAMD,CAPD,EAOG,EAPH,EAlO4C,CAyOpC;EACR;;EAEA,MAAMsF,aAAa,GAAG7I,KAAK,CAACiE,MAAN,CAAa,IAAb,CAAtB;EACAjE,KAAK,CAAC4I,SAAN,CAAgB,MAAM;IACpB,IAAIC,aAAa,CAACvG,OAAlB,EAA2B;MACzBuG,aAAa,CAACvG,OAAd,GAAwB,KAAxB;MACA;IACD,CAJmB,CAIlB;;;IAGF,IAAIR,SAAS,CAACQ,OAAV,CAAkBH,KAAlB,CAAwBP,wBAAxB,KAAqD0B,KAAK,CAAClC,IAA/D,EAAqE;MACnE;IACD;;IAED4C,MAAM,CAACwB,KAAP,CAAc,iCAAgClC,KAAK,CAAClC,IAAN,CAAWK,MAAO,EAAhE;IACAkD,mBAAmB,CAACzD,0BAA0B,CAAC;MAC7CE,IAAI,EAAEkC,KAAK,CAAClC,IADiC;MAE7CL,QAAQ,EAAEuC,KAAK,CAACvC,QAF6B;MAG7CI,SAAS,EAAEW,SAAS,CAACQ,OAAV,CAAkBH;IAHgB,CAAD,CAA3B,EAIf,KAJe,CAAnB;EAKD,CAjBD,EAiBG,CAACmB,KAAK,CAAClC,IAAP,EAAakC,KAAK,CAAClB,QAAnB,EAA6BkB,KAAK,CAACvC,QAAnC,EAA6CiD,MAA7C,EAAqDW,mBAArD,CAjBH;AAkBD,CA/PM"},"metadata":{},"sourceType":"module"}